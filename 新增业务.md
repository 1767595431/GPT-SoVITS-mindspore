# 实现要点备忘

## 1. Redis 对接业务逻辑

```py
#config.ini里的Redis的配置
[redis]
host = 47.97.2.52
port = 6380
db = 0
```



- **配置来源**：`config.ini` 中的 `[redis]` 为默认值，环境变量 `REDIS_HOST/PORT/DB` 可覆盖。启动时 `_init_redis()` 会 `ping` 一次并给出成功/失败日志。
- **启动同步**：FastAPI `lifespan` 内在 Redis 可用的前提下，将本地 `task_store.list_all()` 逐条 `_redis_upsert_task`，确保“本地单点 → Redis”首次对齐。
- **键设计**  
  - Hash：`tts:task:{user_id}:{task_id}`，存储 task 元数据（状态、错误、ISO 时间）。  
  - 全局索引 ZSet：`tts:tasks:index`，Member=`{user_id}:{task_id}`，Score=`updated_at.timestamp()`。  
  - 用户索引 ZSet：`tts:user:{user_id}:index`，Member=`{task_id}`，Score 同上。
- **双写时机**（`TaskStore.upsert/delete`）
  - 任意状态迁移（排队 / 运行中 / 成功 / 失败）或手动删除都会先更新本地 JSON，再调用 `_redis_upsert_task` 或 `_redis_delete_task`。Redis 异常被吞掉，不阻塞主流程。
  - 这样保证 Redis 是“首选读源”，但本地始终是“真实来源 + 容灾”。
- **读路径**（`_list_tasks_internal` & `get_task`）
  - 列表与详情会优先尝试 Redis。若 Redis 不通或数据缺失，则回退到 `task_store` 的内存副本/磁盘 JSON。
  - 使用 Redis ZSet 进行倒序分页，并在必要时解码 Hash 补充字段；状态返回给前端前统一映射为 `wait/run/done/error`。

## 2. 自动清理逻辑
- **配置**：  
  - `[cleanup] retention = 7d`（支持 `30m/2h/1d` 或直接填秒数）；亦可通过环境变量 `TASK_RETENTION_SECONDS` 覆盖。  
  - 扫描周期由 retention 自动推导（30~300s），无需额外参数。
- **运行方式**：FastAPI `lifespan` 启动 `_start_cleanup_thread()`，在退出时 `_stop_cleanup_thread()`，避免僵尸线程。
- **扫描流程**（`_cleanup_expired_tasks_once`）
  1. 计算阈值 `expire_before = now - retention_seconds`。  
  2. 若 Redis 可用：利用 `zrangebyscore(tts:tasks:index, 0, expire_ts)` 拉取候选；再调用 `_redis_get_task` 获取状态/时间。  
  3. 无论 Redis 是否成功，都遍历本地 `task_store.list_all()`，把 `updated_at <= expire_before` 且状态为 `done/error` 的任务加入候选，避免 Redis 挂掉时漏删。  
  4. 针对候选，二次校验：仅当状态属于 `done/error`（或 Redis 未返回视为 None）且更新时间确实过期才执行 `_purge_task_record`。
- **删除动作**（`_purge_task_record` → `_cleanup_task_artifacts`）
  - 先调用 `task_store.delete`（该操作也会写 Redis 删除索引），如本地不存在则直接 `_redis_delete_task` 兜底。  
  - 清空 `output/{user}/{task}` 下结果文件、以及 `Logs/日期/小时/任务ID.log` 的归档。  
  - 控制台打印 `[CLEANUP]` 日志，记录 user/task 及原因，便于审计。

## 3. 用户名 + 多任务 ID 查询逻辑
- **GET /voice-tasks**：保留 `user_id` 与 `task_ids`（逗号或空格分隔）的查询参数。若传入 `task_ids` 必须同时提供 `user_id`；当指定任务 ID 时，返回的分页结果固定 page=1/pageSize=匹配数量。
- **POST /voice-tasks/query**：JSON 版接口，解决 URL 过长问题。Body 结构：
  ```json
  { "page": 1, "page_size": 20, "user_id": "alice", "task_ids": ["t01","t02"] }
  ```
  - `task_ids` 为数组，允许大量任务号；同样要求配合 `user_id` 使用。
- **实现共享**：两个接口均调用 `_list_tasks_internal`，保持完全一致的校验、Redis 优先读取与回退逻辑。
- **实现共享**：两个接口均复用 `_fetch_tasks_by_ids/_fetch_tasks_page`，保持一致的校验、Redis 优先读取与回退逻辑。
- **前端交互**：`web/index.html` 的任务列表会在填写用户 ID 后，通过“应用筛选”按钮将 `user_id` + `task_ids` JSON POST 到 `/voice-tasks/query`，无筛选时再走常规分页刷 GET `/voice-tasks`。自动刷新遵循最近一次的筛选条件。

